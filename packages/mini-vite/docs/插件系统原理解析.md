# 插件系统原理解析

## 1. 架构设计

mini-vite 的插件系统基于 Rollup 插件 API 设计，支持以下核心钩子：

1. **configureServer**：配置开发服务器
2. **resolveId**：解析模块 ID
3. **load**：加载模块内容
4. **transform**：转换模块内容

### 1.1 插件接口定义

```typescript
// plugin.ts
export interface Plugin {
  name: string;
  configureServer?: (server: ServerContext) => void | Promise<void>;
  resolveId?: (
    this: PluginContext,
    id: string,
    importer?: string
  ) => Promise<string | null | undefined> | string | null | undefined;
  load?: (
    this: PluginContext,
    id: string
  ) => Promise<LoadResult> | LoadResult;
  transform?: (
    this: TransformPluginContext,
    code: string,
    id: string,
    options?: { ssr?: boolean }
  ) => Promise<TransformResult> | TransformResult;
}
```

### 1.2 插件上下文

插件上下文为插件提供必要的工具和信息：

```typescript
export interface PluginContext {
  configureServer?: (server: ServerContext) => void | Promise<void>;
  resolve: (id: string, importer?: string) => Promise<ResolvedId | null>;
  // 其他上下文方法...
}
```

## 2. 插件容器实现

在 `server/pluginContainer.ts` 中实现了插件容器：

### 2.1 钩子调用

按顺序调用插件钩子：

```typescript
class PluginContainer {
  async resolveId(id: string, importer?: string) {
    for (const plugin of this.plugins) {
      if (!plugin.resolveId) continue;
      
      const result = await plugin.resolveId.call(
        this.createContext(plugin),
        id,
        importer
      );
      
      if (result != null) {
        return result;
      }
    }
    return null;
  }
}
```

### 2.2 上下文管理

为插件提供上下文对象：

```typescript
private createContext(plugin: Plugin): PluginContext {
  return {
    resolve: (id, importer) => this.resolveId(id, importer),
    // 其他上下文方法...
  };
}
```

### 2.3 错误处理

处理插件执行中的错误：

```typescript
try {
  const result = await plugin.hook.call(context, ...args);
  // 处理结果
} catch (error) {
  // 记录插件错误
  console.error(`[plugin:${plugin.name}] ${error.message}`);
  throw error;
}
```

## 3. 核心插件分析

### 3.1 路径解析插件 (plugins/resolve.ts)

#### 3.1.1 功能概述

路径解析插件负责解析模块的绝对路径，支持：

1. 相对路径解析：`./module.js`
2. 绝对路径解析：`/src/module.js`
3. 裸模块解析：`vue`
4. 文件扩展名自动推断

#### 3.1.2 实现细节

```typescript
export default function resolvePlugin(): Plugin {
  return {
    name: 'mini-vite:resolve',
    async resolveId(id, importer) {
      if (isBareImport(id)) {
        // 处理裸模块导入
        return resolveBareImport(id);
      } else {
        // 处理相对路径和绝对路径
        return resolveRelativeImport(id, importer);
      }
    }
  };
}
```

#### 3.1.3 文件扩展名推断

```typescript
function tryFsResolve(file: string): string | undefined {
  const extensions = ['.ts', '.tsx', '.js', '.jsx', '.json'];
  
  // 尝试直接匹配
  if (fs.existsSync(file)) {
    return file;
  }
  
  // 尝试添加扩展名
  for (const ext of extensions) {
    const withExt = file + ext;
    if (fs.existsSync(withExt)) {
      return withExt;
    }
  }
  
  return undefined;
}
```

### 3.2 ESBuild 转换插件 (plugins/esbuild.ts)

#### 3.2.1 功能概述

ESBuild 转换插件负责将各种格式的源代码转换为浏览器可执行的 JavaScript：

1. TypeScript 转换
2. JSX/TSX 转换
3. 源码映射支持
4. CommonJS 和 ES 模块转换

#### 3.2.2 实现细节

```typescript
export function esbuildTransformPlugin(): Plugin {
  return {
    name: 'mini-vite:esbuild',
    async transform(code, id) {
      if (!isJsRequest(id)) return null;
      
      const loader = getLoader(id);
      const result = await transformWithEsbuild(code, id, {
        loader,
        target: 'esnext',
        format: 'esm',
        sourcemap: true
      });
      
      return result;
    }
  };
}
```

#### 3.2.3 Loader 识别

```typescript
function getLoader(id: string): Loader {
  const ext = path.extname(id).slice(1);
  switch (ext) {
    case 'ts':
      return 'ts';
    case 'tsx':
      return 'tsx';
    case 'jsx':
      return 'jsx';
    default:
      return 'js';
  }
}
```

### 3.3 导入分析插件 (plugins/importAnalysis.ts)

#### 3.3.1 功能概述

导入分析插件负责分析模块中的 ESM 导入语句：

1. 分析 ESM 导入语句
2. 重写第三方依赖路径为预构建产物路径
3. 处理相对路径和绝对路径的导入
4. 注入 HMR 客户端代码

#### 3.3.2 实现细节

```typescript
export function importAnalysisPlugin(): Plugin {
  return {
    name: 'mini-vite:import-analysis',
    async transform(source, importer) {
      if (!isJsRequest(importer)) return null;
      
      // 解析 import 语句
      const [imports] = parse(source);
      const ms = new MagicString(source);
      
      // 处理每个导入语句
      for (let importInfo of imports) {
        const { s: modStart, e: modEnd, n: modSource } = importInfo;
        if (!modSource) continue;
        
        // 重写导入路径
        await rewriteImport(ms, modStart, modEnd, modSource, importer);
      }
      
      // 注入HMR客户端代码
      injectHmrClient(ms, importer);
      
      return {
        code: ms.toString(),
        map: ms.generateMap()
      };
    }
  };
}
```

#### 3.3.3 路径重写

```typescript
async function rewriteImport(
  ms: MagicString,
  modStart: number,
  modEnd: number,
  modSource: string,
  importer: string
) {
  let resolvedId = modSource;
  
  // 处理裸模块导入
  if (isBareImport(modSource)) {
    const bundlePath = normalizePath(
      path.join('/', path.join('node_modules', '.mini-vite', 'deps'), `${modSource}.js`)
    );
    ms.overwrite(modStart, modEnd, bundlePath);
    resolvedId = bundlePath;
  } 
  // 处理相对路径和绝对路径
  else if (modSource.startsWith('.') || modSource.startsWith('/')) {
    const resolved = await this.resolve(modSource, importer);
    if (resolved) {
      ms.overwrite(modStart, modEnd, resolved.id);
      resolvedId = resolved.id;
    }
  }
}
```

### 3.4 CommonJS 兼容插件 (plugins/cjs.ts)

#### 3.4.1 功能概述

CommonJS 兼容插件处理 CommonJS 模块与 ES 模块之间的互操作性：

1. 自动转换 `module.exports` 和 `exports.xx` 为 ES 模块导出
2. 提供 `require()` 函数的浏览器兼容实现
3. 支持混合模块格式

#### 3.4.2 实现细节

```typescript
export function commonjsPlugin(): Plugin {
  return {
    name: 'mini-vite:cjs',
    async transform(code, id) {
      if (!isCjsModule(code)) return null;
      
      // 转换 CommonJS 语法
      const transformed = transformCjsToEsm(code);
      
      return {
        code: transformed.code,
        map: transformed.map
      };
    }
  };
}
```

#### 3.4.3 导出转换

```typescript
function transformCjsToEsm(code: string) {
  // 转换 module.exports = ...
  code = code.replace(/module\.exports\s*=\s*(.+?);/g, 'export default $1;');
  
  // 转换 exports.xxx = ...
  code = code.replace(/exports\.([a-zA-Z0-9_$]+)\s*=\s*(.+?);/g, 'export const $1 = $2;');
  
  return code;
}
```

### 3.5 CSS 插件 (plugins/css.ts)

#### 3.5.1 功能概述

CSS 插件处理 CSS 文件的加载和转换：

1. CSS 模块支持
2. PostCSS 处理
3. CSS 导入分析
4. 热更新支持

#### 3.5.2 实现细节

```typescript
export function cssPlugin(): Plugin {
  return {
    name: 'mini-vite:css',
    async load(id) {
      if (!isCssRequest(id)) return null;
      
      let css = await fs.promises.readFile(id, 'utf-8');
      
      // 处理 CSS Modules
      if (isCssModule(id)) {
        css = await processCssModules(css, id);
      }
      
      // 处理 PostCSS
      css = await processWithPostCSS(css, id);
      
      // 生成 JavaScript 包装器
      const code = generateCssJsWrapper(css, id);
      
      return {
        code,
        map: null
      };
    }
  };
}
```

#### 3.5.3 CSS 模块处理

```typescript
async function processCssModules(css: string, filename: string) {
  const { code } = await compile(css, {
    filename,
    modules: true
  });
  
  // 生成类名映射
  const classes = extractClassNames(code);
  
  return {
    css: code,
    classes
  };
}
```

## 4. 插件执行流程

### 4.1 插件注册

```typescript
// server/index.ts
const plugins: Plugin[] = [
  resolvePlugin(),
  esbuildTransformPlugin(),
  commonjsPlugin(),
  importAnalysisPlugin(),
  cssPlugin(),
  hmrPlugin()
];
```

### 4.2 插件配置

```typescript
// 配置插件
for (const plugin of plugins) {
  if (plugin.configureServer) {
    await plugin.configureServer(serverContext);
  }
}
```

### 4.3 请求处理流程

1. 浏览器发起请求
2. 中间件处理请求
3. 调用插件容器
4. 执行 resolveId 钩子
5. 执行 load 钩子
6. 执行 transform 钩子
7. 返回处理结果

```typescript
// transformRequest.ts
export async function transformRequest(
  url: string,
  serverContext: ServerContext
): Promise<TransformResult | null> {
  // 1. 解析模块 ID
  const resolved = await serverContext.pluginContainer.resolveId(url);
  
  if (!resolved) return null;
  
  // 2. 加载模块内容
  let result = await serverContext.pluginContainer.load(resolved.id);
  
  if (result == null) {
    // 从文件系统加载
    const code = await fs.promises.readFile(resolved.id, 'utf-8');
    result = { code };
  }
  
  // 3. 转换模块内容
  result = await serverContext.pluginContainer.transform(
    result.code,
    resolved.id
  );
  
  return result;
}
```

## 5. 插件开发指南

### 5.1 创建简单插件

```typescript
// 简单的日志插件示例
export function logPlugin(): Plugin {
  return {
    name: 'log-plugin',
    transform(code, id) {
      console.log(`Processing file: ${id}`);
      return code;
    }
  };
}
```

### 5.2 创建复杂插件

```typescript
// 复杂插件示例
export function complexPlugin(options: PluginOptions): Plugin {
  let serverContext: ServerContext;
  
  return {
    name: 'complex-plugin',
    configureServer(server) {
      serverContext = server;
      // 配置服务器
    },
    async resolveId(id, importer) {
      // 自定义解析逻辑
      if (shouldHandleId(id)) {
        return resolveCustomId(id, importer);
      }
    },
    async load(id) {
      // 自定义加载逻辑
      if (shouldHandleLoad(id)) {
        return loadCustomContent(id);
      }
    },
    async transform(code, id) {
      // 自定义转换逻辑
      if (shouldTransform(id)) {
        return transformCustomCode(code, id);
      }
    }
  };
}
```

## 6. 性能优化

### 6.1 缓存机制

```typescript
class PluginContainer {
  private transformCache = new Map<string, TransformResult>();
  
  async transform(code: string, id: string) {
    const cacheKey = `${id}:${hash(code)}`;
    
    // 检查缓存
    if (this.transformCache.has(cacheKey)) {
      return this.transformCache.get(cacheKey)!;
    }
    
    // 执行转换
    const result = await this.doTransform(code, id);
    
    // 存储到缓存
    this.transformCache.set(cacheKey, result);
    
    return result;
  }
}
```

### 6.2 并行处理

```typescript
// 并行执行不相关的插件钩子
async resolveId(id: string, importer?: string) {
  const promises: Promise<any>[] = [];
  
  for (const plugin of this.plugins) {
    if (plugin.resolveId) {
      promises.push(
        plugin.resolveId.call(this.createContext(plugin), id, importer)
      );
    }
  }
  
  const results = await Promise.all(promises);
  // 处理结果...
}
```

## 7. 错误处理和调试

### 7.1 错误捕获

```typescript
try {
  const result = await plugin.hook.call(context, ...args);
  return result;
} catch (error) {
  // 添加插件名称到错误信息
  error.message = `[plugin:${plugin.name}] ${error.message}`;
  throw error;
}
```

### 7.2 调试支持

```typescript
// 插件调试模式
if (process.env.DEBUG_PLUGINS) {
  console.log(`[plugin:${plugin.name}] Executing ${hookName}`);
}
```

## 8. 与其他模块的交互

### 8.1 与 HMR 的交互

```typescript
// 在插件中支持 HMR
export function myPlugin(): Plugin {
  return {
    name: 'my-plugin',
    configureServer(server) {
      // 监听文件变化
      server.watcher.on('change', (file) => {
        if (shouldInvalidate(file)) {
          // 发送 HMR 更新
          server.hmr.send({
            type: 'update',
            // 更新信息...
          });
        }
      });
    }
  };
}
```

### 8.2 与预构建的交互

```typescript
// 插件参与依赖扫描
export function scanPlugin(): Plugin {
  return {
    name: 'scan-plugin',
    setup(build) {
      build.onResolve({ filter: /^[\w@][^:]/ }, ({ path: id }) => {
        // 将依赖添加到预构建列表
        addDependency(id);
        return { path: id, external: true };
      });
    }
  };
}
```